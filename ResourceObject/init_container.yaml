# 初始化容器

init container与应用容器的区别如下：
1、初始化容器的运行方式与应用容器不同，它们必须先于应用容器执行完成，当设置多个初始化容器时，将按顺序逐个运行，并且只有一个初始化容器运行成功后才能运行下一个初始化容器，再所有的初始化容器都运行成功，k8s才会创建和运行应用容器；
2、在初始化容器中，也可以定义资源限制、volume使用、安全策略。但资源限制与应用容器略有不同：
  >. 如果多个初始化容器都定义来资源请求/资源限制，则取最大都值作为所有初始化容器的资源请求/资源限制值；
  >. pod的有效资源请求值/资源限制值取以下二者中的较大值：1、所有应用容器的资源请求/资源限制值之和；2、初始化容器的有效资源请求值/资源限制值；
  >. 调度算法将基于pod的有效资源请求值/资源限制值进行计算，也就是说，初始化容器可以为初始化操作预留系统资源，即使后续应用容器无须使用这些资源。
  >. pod的有效QoS等级适用与初始化容器和应用容器；
  >. 资源配额和限制将根据pod的有效资源请求值/资源限制值计算生效；
  >. pod级别的cgroup将基于pod的有效资源请求/限制，与调度机制一致；
3、初始化容器不能设置readinessProbe探针，因为此探针必须在容器成功后才能继续运行，初始化容器成功运行后就关闭，所以不能使用；

pod重新启动时，初始化容器将会重新运行。常见pod重启场景如下：
1、初始化容器的镜像被更新时，初始化容器会被重新运行，导致pod重启。仅更新应用容器的镜像只会使得应用容器重启；
2、pod的infrastructure容器更新时，pod将会重启；
3、若pod中的所有应用容器都终止了，并且重启策略为Always，则pod会重启；

apiVersion: v1
kind: Pod
metadata:
  name: string
spec:
  # 初始化容器
  initContainers:
    - name: string
      image: string
  containers:
    - name: string
      image: string
